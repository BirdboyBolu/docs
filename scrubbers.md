1. хранители следят друг за другом!
    a. каждую минуту один из хранителей пингует всех других хранителей в семье кастомера
    b. в следующую минуту другой хранитель пингует всех остальных хранителей и т.д.
    c. если кастомер в сети, хранители этого не делают - он сам всех пингует и принимает решения
    d. хранитель сперва пингует кастомера и если он не в сети то только тогда делает пинг всех хранителей
    e. если кастомер в сети, то хранитель в следующий раз запустит пинг только через n минут, n = число хранителей
    f. в итоге каждую минуту кастомер будет получать (если он в сети) по одному пингу от одного из хранителей по кругу

2. все хранители знают друг друга!
    a. кастомер сообщает каждому хранителю всю семью хранителей каждый раз когда семья меняется
    b. только кастомер может изменить семью - нанять или уволить хранителя
    c. хранители также публикуют в DHT свою позицию в семье этого кастомера
    d. из DHT любой другой узел вне семьи сможет узнать полный список всех хранителей
    e. когда хранители пингуют друг друга они также сообщают известный им список хранителей - для проверки
    f. важно минимизировать количество регулярных обращений к DHT

3. хранитель сам нанимает "запасного" когда обнаруживает что другой хранитель не в сети!
    a. обнаружив другого хранителя, который не отвечает, пингующий хранитель запоминает его
    b. он передает "мертвого" следующему живому хранителю, который будет проводить пинг в следующую минуту
    c. следующий пингующий тоже обнаруживает мертвого и запоминает и передает эту информацию следующему
    d. после нескольких итераций, когда несколько хранителей вместе обнаруживают мертвого, нанимается запасной

4. запасной хранитель добавлен в семью этого клиента!
    a. запасной хранитель назначается на туже позицию, на которой был мертвый хранитель но не замещает его в семье
    b. запасной хранитель публикует в DHT информацию о себе
    c. запасной хранитель находит "ребилдера" для того что бы реконструировать потерянный кусок данных клиента
    d. запасной хранитель принимает пересобранные куски данных от ребилдера и хранит их как обычный хранитель
    e. несколько ребилдеров может быть запущенно если ожидаемый объем данных достаточно велик
    f. запасной также участвуют в "периодическом пинге" и следит за другими хранителями и запасными

5. ребилдер получает задание от запасного!
    a. ребилдер сканирует DHT и выясняет всех хранителей и запасных в семье
    b. ребилдер пингует всех хранителей и запасных и начинает скачивать с них куски данных
    c. блок за блоком ребилдер собирает потерянный фрагменты и посылает их запасному
    d. если параллельно работают несколько ребилдеров то они берут разные блоки - запасной управляет этим

6. клиент возвращается в сеть и решает ситуацию с запасными и мертвыми!
    a. клиент может запросить "историю пингов" от всех хранителей и запасных и составить рейтинг надежности 
    b. если мертвый хранитель так и не вернулся в сеть - запасной просто меняет его и перестает быть запасным
    c. если мертвый хранитель вернулся в сеть, то на основе рейтинга клиент может решить кто надежнее
    d. если мертвый вернулся в сеть очень быстро, то запасной может сам отказатся от своей роли и выйти из семьи
    e. клиент мож

7. клиент так и не возвращается в сеть вообще!
    a. хранители и клиент заранее договариваются на максимальный срок "контракта" в момент первого контакта
    b. запасной знает срок контракта мертвого хранителя из DHT, он "унаследует" тот же срок "контракта"
    c. хранители и запасные после истечения срока их контрактов автоматически выходят из семьи и данные будут потеряны

